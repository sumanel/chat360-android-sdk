Index: chatbot/src/main/java/com/chat360/chatbot/common/models/ConfigService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chat360.chatbot.common.models\n\nimport android.app.Application\nimport com.chat360.chatbot.common.CoreConfigs\n\nclass ConfigService {\n\n    private var config: CoreConfigs\n    private var baseUrl: String? = null\n\n    object WebEventHandler {\n        var handleWindowEvent: ((Map<String, String>) -> Map<String, String>)? = null\n    }\n\n    init {\n        config = CoreConfigs(\"\", Application(),false,null, false, false)\n    }\n\n    companion object {\n        private var configInstance: ConfigService? = null\n        public fun getInstance(): ConfigService? {\n            if (configInstance == null) {\n                synchronized(ConfigService::class.java) {\n                    if (configInstance == null) {\n                        configInstance = ConfigService()\n                    }\n                }\n            }\n            return configInstance\n        }\n\n    }\n\n    fun setConfigData(config: CoreConfigs): Boolean {\n        this.config = config\n        return true\n    }\n\n    fun getConfig(): CoreConfigs {\n        return config\n    }\n\n    fun setBaseUrl(url: String) {\n        baseUrl = url;\n    }\n\n    fun getBaseUrl(): String? {\n        return baseUrl;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chatbot/src/main/java/com/chat360/chatbot/common/models/ConfigService.kt b/chatbot/src/main/java/com/chat360/chatbot/common/models/ConfigService.kt
--- a/chatbot/src/main/java/com/chat360/chatbot/common/models/ConfigService.kt	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/chatbot/src/main/java/com/chat360/chatbot/common/models/ConfigService.kt	(date 1763636286310)
@@ -10,6 +10,9 @@
 
     object WebEventHandler {
         var handleWindowEvent: ((Map<String, String>) -> Map<String, String>)? = null
+        var sendEventToBot: ((Map<String, String>) -> Unit)? = { event ->
+            Chat360JSBridge.send("CHAT360_WINDOW_EVENT", event)
+        }
     }
 
     init {
Index: chatbot/src/main/java/com/chat360/chatbot/common/Chat360.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chat360.chatbot.common\n\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport androidx.fragment.app.Fragment\nimport com.chat360.chatbot.android.ChatActivity\nimport com.chat360.chatbot.android.ChatFragment\nimport com.chat360.chatbot.common.models.ConfigService\n\nclass Chat360 {\n    var coreConfig: CoreConfigs? = null\n\n    private lateinit var botPluginInstance: Chat360\n\n    fun getInstance(): Chat360 {\n        synchronized(Chat360::class.java) {\n            botPluginInstance = Chat360()\n        }\n        return botPluginInstance\n    }\n\n    fun setBaseUrl(url: String) {\n        ConfigService.getInstance()?.setBaseUrl(url)\n    }\n\n    fun setHandleWindowEvent(handleWindowEvent: (Map<String, String>) -> Map<String, String>) {\n        ConfigService.WebEventHandler.handleWindowEvent = handleWindowEvent\n    }\n\n    fun startBot(context: Context) {\n        try {\n            if (validate(context)) {\n                ConfigService.getInstance()!!.setConfigData(coreConfig!!)\n                val intent = Intent(context, ChatActivity::class.java)\n                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n                context.startActivity(intent)\n            }\n        } catch (e: java.lang.Exception) {\n            throw java.lang.Exception(\n                \"\"\"\n            Exception in staring chat bot ::\n            Exception message :: ${e.message}\n            \"\"\".trimIndent()\n            )\n        }\n    }\n\n    @Throws(Exception::class)\n    fun getChatBotView(context: Context): Fragment? {\n        try {\n            if (validate(context)) {\n                ConfigService.getInstance()?.setConfigData(coreConfig!!)\n                return ChatFragment()\n            }\n        } catch (e: Exception) {\n            throw Exception(\n                \"\"\"\n                Exception in staring chat bot ::\n                Exception message :: ${e.message}\n                \"\"\".trimIndent()\n            )\n        }\n        return null\n    }\n\n    @Deprecated(\"Not Available for now\")\n    fun getUnreadMessageCount(): Int {\n        return Constants.UNREAD_MESSAGE_COUNT\n    }\n\n    @Throws(java.lang.Exception::class)\n    private fun validate(context: Context?): Boolean {\n        if (context == null) {\n            throw java.lang.Exception(\"Context passed is null. Please pass valid context\")\n        }\n        if (coreConfig == null) {\n            throw java.lang.Exception(\"Please initialise config, it cannot be null.\")\n        }\n        if (coreConfig?.botId == null || coreConfig?.botId?.trim()!!.isEmpty()) {\n            throw java.lang.Exception(\"botId is not configured. Please set botId before calling startChatbot()\")\n        }\n        if (!(coreConfig?.version === 1 || coreConfig?.version === 2)) {\n            throw java.lang.Exception(\"version can be either 1 or 2\")\n        }\n        return true\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chatbot/src/main/java/com/chat360/chatbot/common/Chat360.kt b/chatbot/src/main/java/com/chat360/chatbot/common/Chat360.kt
--- a/chatbot/src/main/java/com/chat360/chatbot/common/Chat360.kt	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/chatbot/src/main/java/com/chat360/chatbot/common/Chat360.kt	(date 1763635460709)
@@ -28,6 +28,10 @@
         ConfigService.WebEventHandler.handleWindowEvent = handleWindowEvent
     }
 
+    fun sendEventToBot(event: Map<String, String>) {
+        ConfigService.WebEventHandler.sendEventToBot?.let { it(event) }
+    }
+
     fun startBot(context: Context) {
         try {
             if (validate(context)) {
Index: chatbot/src/main/java/com/chat360/chatbot/android/ChatFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chat360.chatbot.android\n\nimport android.Manifest\nimport android.app.Activity\nimport android.app.AlertDialog\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageInfo\nimport android.content.pm.PackageManager\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.graphics.Color\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.Handler\nimport android.os.Looper\nimport android.os.Message\nimport android.provider.MediaStore\nimport android.provider.Settings\nimport android.provider.Settings.SettingNotFoundException\nimport android.text.TextUtils\nimport android.util.Log\nimport android.view.*\nimport android.webkit.*\nimport android.widget.FrameLayout\nimport android.widget.ImageView\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport androidx.core.content.FileProvider\nimport androidx.core.content.PermissionChecker\nimport androidx.core.content.PermissionChecker.checkSelfPermission\nimport androidx.core.graphics.drawable.DrawableCompat\nimport androidx.fragment.app.Fragment\nimport com.chat360.chatbot.R\nimport com.chat360.chatbot.common.Chat360SnackBarHelper\nimport com.chat360.chatbot.common.Constants\nimport com.chat360.chatbot.common.models.ConfigService\nimport com.google.android.material.bottomsheet.BottomSheetDialog\nimport java.io.File\nimport java.io.IOException\nimport org.json.JSONObject\nimport java.text.SimpleDateFormat\nimport java.util.*\n\n\nclass ChatFragment : Fragment() {\n\n    private var requestedPermission: String? = null\n    private var mCameraPhotoPath: String? = null\n    private var mCameraVideoPath: String? = null\n    private var mAudioPath: String? = null\n    private var isMultiFileUpload = false\n    private var shouldKeepApplicationInBackground = true\n    private var mFilePathCallback: ValueCallback<Array<Uri?>>? = null\n    private var geoCallback: GeolocationPermissions.Callback? = null\n    private var geoOrigin: String? = null\n    private lateinit var webView: WebView\n    private lateinit var imageViewClos: ImageView\n    private lateinit var topLayout: FrameLayout\n    private var isMediaUploadOptionSelected = false\n    var url = \"\"\n\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?\n    ): View {\n        (activity as AppCompatActivity?)?.supportActionBar?.hide()\n        val view = inflater.inflate(R.layout.fragment_chat, container, false)\n        return view\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        Constants.UNREAD_MESSAGE_COUNT = 0\n        webView = view.findViewById(R.id.webView)\n        imageViewClos = view.findViewById(R.id.imageViewClose)\n        topLayout = view.findViewById(R.id.topLayout)\n\n        setCloseButtonColor()\n        setAppBarColor()\n        setStatusBarColor()\n        if (!Constants.isNetworkAvailable(requireActivity())) {\n            Constants.showNoInternetDialog(requireActivity())\n        } else {\n            setupViews()\n        }\n        showCloseButton()\n        setAppBarColorFromHex()\n        setStatusBarColorFromHex()\n        setCloseButtonColorFromHex()\n        webView.clearCache(true)\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        webView.destroy()\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        webView.loadDataWithBaseURL(null, \"\", \"text/html\", \"utf-8\", null)\n        webView.clearHistory()\n        webView.onPause()\n        webView.removeAllViews()\n        webView.destroy()\n    }\n\n    private fun showCloseButton() {\n        val showCloseButton = ConfigService.getInstance()?.getConfig()?.showCloseButton\n        if (showCloseButton!!) {\n            imageViewClos.visibility = View.VISIBLE\n            setCloseButtonColor()\n        } else {\n            imageViewClos.visibility = View.GONE\n        }\n    }\n\n    private fun setupViews() {\n        val botId = ConfigService.getInstance()?.getConfig()?.botId\n        val flutterBool = ConfigService.getInstance()?.getConfig()?.flutter\n        val meta = ConfigService.getInstance()?.getConfig()?.meta\n        val inputString= meta.toString()\n        val jsonObject = JSONObject()\n\n        try {\n            val jsonContent = inputString.substring(1, inputString.length - 1)\n            val keyValuePairs = jsonContent.split(\", \")\n            for (pair in keyValuePairs) {\n                val (key, value) = pair.split(\"=\")\n                jsonObject.put(key, value)\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        var chat360BaseUrl = if(ConfigService.getInstance()?.getConfig()?.isDebug == true) {\n            requireContext().resources.getString(R.string.chat360_staging_url)\n        } else {\n            requireContext().resources.getString(R.string.chat360_base_url)\n        }\n\n        ConfigService.getInstance()?.getBaseUrl()?.let { baseUrl ->\n            chat360BaseUrl = baseUrl\n        }\n\n        chat360BaseUrl += if (ConfigService.getInstance()?.getConfig()?.useNewUI == true) {\n            \"/web_bot?h=\"\n        } else {\n            \"/page?h=\"\n        }\n\n        val fcmToken = ConfigService.getInstance()?.getConfig()?.deviceToken\n        val appId = \"\"\n        val devicemodel = Build.MODEL\n        url = if (flutterBool == true) {\n            \"$chat360BaseUrl$botId&store_session=1&fcm_token=$fcmToken&app_id=$appId&is_mobile=true&meta=$jsonObject&flutter_sdk_type=android&mobile=1&device_name=$devicemodel\"\n        } else {\n            \"$chat360BaseUrl$botId&store_session=1&fcm_token=$fcmToken&app_id=$appId&is_mobile=true&meta=$jsonObject&mobile=1&device_name=$devicemodel\"\n        }\n\n        webView.settings.apply {\n            domStorageEnabled = true\n            setSupportMultipleWindows(true)\n            javaScriptCanOpenWindowsAutomatically = true\n            allowFileAccess = true\n            loadsImagesAutomatically = true\n            mediaPlaybackRequiresUserGesture = false\n            javaScriptEnabled = true\n            databaseEnabled = true\n            setGeolocationEnabled(true)\n            setSupportZoom(true)\n            //cacheMode = WebSettings.LOAD_CACHE_ELSE_NETWORK\n        }\n\n        webChromeClient()\n        webView.scrollBarStyle = View.SCROLLBARS_INSIDE_OVERLAY\n        webView.clearView()\n        webView.measure(100, 100)\n        webView.settings.useWideViewPort = true\n        webView.settings.loadWithOverviewMode = true\n        webView.webViewClient = object : WebViewClient() {\n            override fun onPageFinished(view: WebView?, url: String?) {\n                super.onPageFinished(view, url)\n                Handler().postDelayed({\n                    injectJavascript(view)\n                    injectJavascriptForCommunication(view)\n                }, 100) // Adjust the delay as needed\n            }\n        }\n        webView.loadUrl(url)\n        webView.addJavascriptInterface(JSBridge(requireActivity()), \"Bridge\")\n        webView.addJavascriptInterface(WebCommunicationBridge(this), \"WebCommunicationBridge\")\n\n        imageViewClos.setOnClickListener {\n            requireActivity().onBackPressed()\n        }\n    }\n\n\n\n    private fun injectJavascript(view: WebView?) {\n        val webView = requireNotNull(view) { \"WebView cannot be null\" }\n\n        webView.loadUrl(\n            \"\"\"\n        javascript: (function(){\n                let closeButton = document.querySelector(\".cursor-pointer\");\n                if (closeButton) {\n                    closeButton.addEventListener(\"click\", function () {\n                    console.log('Button clicked from JavaScript');\n                        Bridge.calledFromJS();\n                    });\n                }\n        })()\n    \"\"\"\n        )\n    }\n\n\n    class JSBridge(private val activity: Activity) {\n        @JavascriptInterface\n        fun calledFromJS() {\n            activity.onBackPressed()\n\n        }\n    }\n\n    class WebCommunicationBridge(private val activity: ChatFragment) {\n        @JavascriptInterface\n        fun postMessage(message: String) {\n            Log.d(\"WebCommunicationBridge\", \"Message received from web: $message\")\n            try {\n                val event = mutableMapOf<String, String>()\n                val json = JSONObject(message)\n                json.keys().forEach { key ->\n                    event[key] = json.optString(key)\n                }\n\n                val metadata = ConfigService.WebEventHandler.handleWindowEvent?.invoke(event)\n\n                metadata?.let {\n                    activity.sendResponseToWeb(\n                        \"CHAT360_WINDOW_EVENT\",\n                        it\n                    )\n                }\n            } catch (e: Exception) {\n                Log.e(\"WebCommunicationBridge\", \"Error handling message\", e)\n            }\n        }\n    }\n\n\n    private fun injectJavascriptForCommunication(view: WebView?){\n        val jsBridgeCode = \"\"\"\n            (function() {\n                window.sendToApp = function(event) {\n                    if (!event || !event.type) {\n                        console.log('sendToApp requires event.type');\n                        return;\n                    }\n                    if (window.WebCommunicationBridge && window.WebCommunicationBridge.postMessage) {\n                        window.WebCommunicationBridge.postMessage(JSON.stringify(event));\n                    } else {\n                        console.log(\"WebCommunicationBridge not available:\", event);\n                    }\n                };\n        \n                window.receiveFromApp = function(event) {\n                    console.log(\"Received from app:\", event);\n                    if (window.onAppEvent) {\n                        window.onAppEvent(event);\n                    }\n                };\n            })();\n        \"\"\".trimIndent()\n\n        view?.evaluateJavascript(jsBridgeCode) {\n            print(it)\n        }\n    }\n\n    fun sendResponseToWeb(type: String, data: Map<String, String>?) {\n        var inner : String? = null\n        if (data.isNullOrEmpty()) {\n            inner = \"{}\"\n        }\n\n        inner = data?.entries?.joinToString(\", \") { (key, value) ->\n            \"\"\"$key: '$value'\"\"\"\n        }\n        Log.d(\"JavaScriptConsole\", \"{type: '$type', data:{ $inner} \")\n        val jsCode = \"window.receiveFromApp({type: '$type', data: {$inner}});\"\n\n        activity?.runOnUiThread {\n            webView.evaluateJavascript(jsCode) { result ->\n                if (result == null || result == \"null\") {\n                    Log.d(\"NativeToWeb\", \"Sent event $type successfully.\")\n                } else {\n                    Log.e(\"NativeToWeb\", \"Error sending message: $result\")\n                }\n            }\n        }\n\n    }\n\n\n    //Adding callbacks and the permission function for web-view requirements\n    private fun webChromeClient() {\n        webView.webChromeClient = object : WebChromeClient() {\n            private var mCustomView: View? = null\n            private var mCustomViewCallback: CustomViewCallback? = null\n            private var mOriginalOrientation = 0\n            private var mOriginalSystemUiVisibility = 0\n\n            override fun onConsoleMessage(consoleMessage: ConsoleMessage): Boolean {\n                Log.d(\n                    \"JavaScriptConsole\",\n                    \"${consoleMessage.message()} -- From line ${consoleMessage.lineNumber()} of ${consoleMessage.sourceId()}\"\n                )\n                return true\n            }\n\n            // For Android 5.0\n            override fun onShowFileChooser(\n                view: WebView,\n                filePath: ValueCallback<Array<Uri>>,\n                fileChooserParams: FileChooserParams\n            ): Boolean {\n                if (mFilePathCallback != null) {\n                    mFilePathCallback!!.onReceiveValue(null)\n                }\n                mFilePathCallback = filePath as ValueCallback<Array<Uri?>>?\n                isMediaUploadOptionSelected = false\n                showBottomSheet()\n                return true\n            }\n\n            override fun getDefaultVideoPoster(): Bitmap? {\n                return if (mCustomView == null) {\n                    null\n                } else BitmapFactory.decodeResource(context?.resources, 2130837573)\n            }\n\n            override fun onHideCustomView() {\n                if (activity != null) {\n                    (activity!!.window.decorView as FrameLayout).removeView(mCustomView)\n                    if (activity != null) {\n                        activity!!.window.decorView.systemUiVisibility = mOriginalSystemUiVisibility\n                    }\n                    activity!!.requestedOrientation = mOriginalOrientation\n                }\n                mCustomView = null\n                mCustomViewCallback!!.onCustomViewHidden()\n                mCustomViewCallback = null\n            }\n\n            override fun onShowCustomView(\n                paramView: View, paramCustomViewCallback: CustomViewCallback\n            ) {\n\n                if (mCustomView != null) {\n                    onHideCustomView()\n                    return\n                }\n                mCustomView = paramView\n                if (activity != null) {\n                    mOriginalSystemUiVisibility = activity!!.window.decorView.systemUiVisibility\n                    mOriginalOrientation = activity!!.requestedOrientation\n                }\n                mCustomViewCallback = paramCustomViewCallback\n                if (activity != null) {\n                    (activity!!.window.decorView as FrameLayout).addView(\n                        mCustomView, FrameLayout.LayoutParams(-1, -1)\n                    )\n                    activity!!.window.decorView.systemUiVisibility =\n                        3846 or View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n                }\n            }\n\n            override fun onCreateWindow(\n                view: WebView, isDialog: Boolean, isUserGesture: Boolean, resultMsg: Message\n            ): Boolean {\n                val newWebView = context?.let { WebView(it) }\n                val transport = resultMsg.obj as WebView.WebViewTransport\n                transport.webView = newWebView\n                resultMsg.sendToTarget()\n                if (newWebView != null) {\n                    newWebView.webViewClient = object : WebViewClient() {\n                        override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean {\n                            val browserIntent = Intent(Intent.ACTION_VIEW)\n                            browserIntent.data = Uri.parse(url)\n                            startActivity(browserIntent)\n                            return true\n                        }\n                    }\n                }\n                return true\n            }\n\n            override fun onPermissionRequest(request: PermissionRequest) {\n\n                for (permission in request.resources) {\n                    when (permission) {\n                        \"android.webkit.resource.AUDIO_CAPTURE\" -> {\n                            if (checkSelfPermission(\n                                    requireContext(), Manifest.permission.RECORD_AUDIO\n                                ) != PermissionChecker.PERMISSION_GRANTED\n                            ) {\n                                requestPermissions(arrayOf(Manifest.permission.RECORD_AUDIO), 1)\n                                request.grant(request.resources)\n                            } else {\n                                request.grant(request.resources)\n                                //checkAndLaunchAudioRecord()\n                            }\n                        }\n                    }\n                }\n            }\n\n            override fun onGeolocationPermissionsShowPrompt(\n                origin: String, callback: GeolocationPermissions.Callback\n            ) {\n                if (context == null) return\n                if (!hasLocationPermissionInManifest(requireContext())) {\n                    Chat360SnackBarHelper().showMessageInSnackBar(\n                        requireView(), \"No location permission\"\n                    )\n                    return\n                }\n                if (checkForLocationPermission(requireContext())) {\n                    if (!isLocationEnabled(requireContext())) {\n                        showGPSEnableDialog(requireContext())\n                    }\n\n                    callback.invoke(origin, true, false)\n\n                } else {\n                    geoOrigin = origin\n                    geoCallback = callback\n                }\n            }\n        }\n    }\n\n\n    private fun showGPSEnableDialog(context: Context) {\n        AlertDialog.Builder(context)\n            .setMessage(\"Please allow your location.\")\n            .setPositiveButton(\n                \"Allow\"\n            ) { _, _ ->\n                context.startActivity(\n                    Intent(\n                        Settings.ACTION_LOCATION_SOURCE_SETTINGS\n                    )\n                )\n            }\n            .setNegativeButton(\"Cancel\") { _, _ ->\n                Chat360SnackBarHelper().showMessageInSnackBar(\n                    requireView(), \"No location permission\"\n                )\n            }\n            .show()\n    }\n\n    private fun hasAudioPermissionInManifest(context: Context): Boolean {\n        var packageInfo: PackageInfo? = null\n        try {\n            packageInfo = context.packageManager.getPackageInfo(\n                context.packageName, PackageManager.GET_PERMISSIONS\n            )\n            val permissions = packageInfo.requestedPermissions\n            if (permissions == null || permissions.isEmpty()) {\n                return false\n            }\n            for (perm in permissions) {\n                if (perm == Manifest.permission.RECORD_AUDIO) return true\n            }\n        } catch (e: PackageManager.NameNotFoundException) {\n            //Exception occurred\n            return false\n        }\n        return false\n    }\n\n    private fun hasLocationPermissionInManifest(context: Context): Boolean {\n        var packageInfo: PackageInfo? = null\n        try {\n            packageInfo = context.packageManager.getPackageInfo(\n                context.packageName, PackageManager.GET_PERMISSIONS\n            )\n            val permissions = packageInfo.requestedPermissions\n            if (permissions == null || permissions.isEmpty()) {\n                return false\n            }\n            for (perm in permissions) {\n                if (perm == Manifest.permission.ACCESS_FINE_LOCATION) return true\n            }\n        } catch (e: PackageManager.NameNotFoundException) {\n            //Exception occurred\n            return false\n        }\n        return false\n    }\n\n    fun hasPermissions(context: Context, vararg permissions: String): Boolean = permissions.all {\n        ActivityCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED\n    }\n\n    private fun checkForLocationPermission(context: Context): Boolean {\n        val PERMISSIONS = arrayOf(\n            Manifest.permission.ACCESS_FINE_LOCATION,\n            Manifest.permission.ACCESS_COARSE_LOCATION\n        )\n        return if (hasPermissions(context, *PERMISSIONS)\n        ) {\n            true\n        } else {\n            requestedPermission = Manifest.permission.ACCESS_FINE_LOCATION\n            requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)\n\n            requestedPermission = Manifest.permission.ACCESS_COARSE_LOCATION\n            requestPermissionLauncher.launch(Manifest.permission.ACCESS_COARSE_LOCATION)\n            false\n        }\n    }\n\n    fun isLocationEnabled(context: Context): Boolean {\n        var locationMode = 0\n        val locationProviders: String\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n            locationMode = try {\n                Settings.Secure.getInt(context.contentResolver, Settings.Secure.LOCATION_MODE)\n            } catch (e: SettingNotFoundException) {\n                e.printStackTrace()\n                return false\n            }\n            locationMode != Settings.Secure.LOCATION_MODE_OFF\n        } else {\n            locationProviders = Settings.Secure.getString(\n                context.contentResolver,\n                Settings.Secure.LOCATION_PROVIDERS_ALLOWED\n            )\n            !TextUtils.isEmpty(locationProviders)\n        }\n    }\n\n    private fun setAppBarColor() {\n        try {\n            val color = ConfigService.getInstance()?.getConfig()?.statusBarColor\n            if (color != -1) {\n                val window: Window = requireActivity().window\n                // clear FLAG_TRANSLUCENT_STATUS flag:\n                window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)\n                // add FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS flag to the window\n                window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n                // finally change the color\n                context?.let {\n\n\n                    val frameLayout: FrameLayout? = view?.findViewById(R.id.topLayout)\n\n                    // Set the background color programmatically\n                    frameLayout?.setBackgroundColor(ContextCompat.getColor(it, color!!))\n                }\n            }\n        } catch (e: java.lang.Exception) {\n            Log.e(\"StatusBarException\", e.toString())\n        }\n    }\n\n    //Setting the statusBar Color from the resources\n    private fun setStatusBarColor() {\n        try {\n            val color = ConfigService.getInstance()?.getConfig()?.statusBarColor\n            if (color != -1) {\n                val window: Window = requireActivity().window\n                // clear FLAG_TRANSLUCENT_STATUS flag:\n                window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)\n                // add FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS flag to the window\n                window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n                // finally change the color\n                context?.let {\n                    window.statusBarColor = ContextCompat.getColor(it, color!!)\n                }\n            }\n        } catch (e: java.lang.Exception) {\n            Log.e(\"StatusBarException\", e.toString())\n        }\n    }\n\n    private fun setStatusBarColorFromHex() {\n        try {\n            val color = ConfigService.getInstance()?.getConfig()?.statusBarColorFromHex\n            if (!color.isNullOrEmpty() && activity != null) {\n                val window: Window = requireActivity().window\n                window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)\n                window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n                window.statusBarColor = Color.parseColor(color)\n\n            }\n        } catch (e: java.lang.Exception) {\n            Log.e(\"StatusBarException\", e.toString())\n        }\n    }\n\n    private fun setAppBarColorFromHex() {\n        try {\n            val color = ConfigService.getInstance()?.getConfig()?.statusBarColorFromHex\n            if (!color.isNullOrEmpty() && activity != null) {\n                val window: Window = requireActivity().window\n                window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)\n                window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n                activity?.findViewById<FrameLayout?>(R.id.topLayout)\n                    ?.setBackgroundColor(Color.parseColor(color))\n\n            }\n        } catch (e: java.lang.Exception) {\n            Log.e(\"StatusBarException\", e.toString())\n        }\n    }\n\n    //Setting the Close Button Color from the resources\n    private fun setCloseButtonColor() {\n        try {\n            val color = ConfigService.getInstance()?.getConfig()?.closeButtonColor\n            if (color != -1 && context != null) {\n                DrawableCompat.setTint(\n                    DrawableCompat.wrap(imageViewClos.drawable),\n                    ContextCompat.getColor(requireContext(), color!!)\n                )\n            }\n        } catch (e: java.lang.Exception) {\n            Log.e(\"CloseButtonException\", e.toString())\n        }\n    }\n\n    //Setting the Close Button Color Code From Hex Color Code\n    private fun setCloseButtonColorFromHex() {\n        try {\n            val color = ConfigService.getInstance()?.getConfig()?.closeButtonColorFromHex\n            if (!color.isNullOrEmpty()) {\n                DrawableCompat.setTint(\n                    DrawableCompat.wrap(\n                        imageViewClos.drawable\n                    ), Color.parseColor(color)\n                )\n            }\n        } catch (e: java.lang.Exception) {\n            Log.e(\"CloseButtonException\", e.toString())\n        }\n    }\n\n    private fun showCameraOptionsDialog() {\n        val options = arrayOf(\"Take Photo\", \"Record Video\")\n        val builder = AlertDialog.Builder(requireContext())\n        builder.setTitle(\"Choose an option\")\n        builder.setItems(options) { dialog, which ->\n            when (which) {\n                0 -> {isMediaUploadOptionSelected = true\n                    checkAndLaunchCamera()\n                    dialog.dismiss()\n                }\n                1 -> {isMediaUploadOptionSelected = true\n                    checkAndLaunchVideoCamera()\n                dialog.dismiss()}\n            }\n        }\n        builder.setOnDismissListener {\n            if (!isMediaUploadOptionSelected) {\n                resetFilePathCallback()\n            }\n        }\n\n        builder.show()\n    }\n\n    //while uploading the file it'll show the bottom-sheet layout\n    private fun showBottomSheet() {\n        if (context != null) {\n            val bottomSheetDialog = BottomSheetDialog(requireContext())\n            bottomSheetDialog.setContentView(R.layout.fragment_upload_bottom_sheet)\n            val cameraLayout = bottomSheetDialog.findViewById<ImageView>(R.id.imageViewCamera)\n            val videoLayout = bottomSheetDialog.findViewById<ImageView>(R.id.imageViewVideo)\n            val fileLayout = bottomSheetDialog.findViewById<ImageView>(R.id.imageViewfile)\n            cameraLayout?.setOnClickListener {\n\n                isMediaUploadOptionSelected = true\n                checkAndLaunchCamera()\n                bottomSheetDialog.dismiss()\n\n            }\n            videoLayout?.setOnClickListener{\n\n                isMediaUploadOptionSelected = true\n                checkAndLaunchVideoCamera()\n                bottomSheetDialog.dismiss()\n            }\n            fileLayout?.setOnClickListener {\n                isMediaUploadOptionSelected = true\n                checkAndLaunchFilePicker()\n                bottomSheetDialog.dismiss()\n            }\n            bottomSheetDialog.setOnDismissListener {\n                if (!isMediaUploadOptionSelected) {\n                    resetFilePathCallback()\n                }\n            }\n            bottomSheetDialog.show()\n        }\n    }\n\n    //Checking if User Has Given the Storage Permission\n    private fun checkForStoragePermission(context: Context): Boolean {\n        return if (ContextCompat.checkSelfPermission(\n                context, Manifest.permission.READ_EXTERNAL_STORAGE\n            ) == PackageManager.PERMISSION_GRANTED\n        ) {\n            true\n        } else {\n            requestedPermission = Manifest.permission.READ_EXTERNAL_STORAGE\n            requestPermissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE)\n            false\n        }\n    }\n\n    //Checking the permission is true and launching the file intent to choose the file from storage\n    private fun checkAndLaunchFilePicker() {\n        if (context != null) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n                launchFileIntent()\n            } else {\n                if (checkForStoragePermission(requireContext())) {\n                    launchFileIntent()\n                }\n            }\n        }\n    }\n\n    @Throws(IOException::class)\n    private fun createAudioFile(): File? {\n\n        // Create an image file name\n        val timeStamp = SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.getDefault()).format(Date())\n        val imageFileName = \"Chat360WAV_\" + timeStamp + \"_\"\n        val storageDir = requireContext().externalCacheDir\n        return File.createTempFile(\n            imageFileName, \".wav\", storageDir\n        )\n    }\n\n    //Will create the image_file\n    @Throws(IOException::class)\n    private fun createImageFile(): File? {\n        // Create an image file name\n        val timeStamp = SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.getDefault()).format(Date())\n        val imageFileName = \"Chat360JPEG_\" + timeStamp + \"_\"\n        val storageDir = requireContext().externalCacheDir\n        return File.createTempFile(\n            imageFileName,  /* prefix */\n            \".jpg\",  /* suffix */\n            storageDir /* directory */\n        )\n    }\n\n    @Throws(IOException::class)\n    private fun createVideoFile(): File? {\n        // Create a video file name\n        val timeStamp = SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.getDefault()).format(Date())\n        val videoFileName = \"Chat360Video_\" + timeStamp + \"_\"\n        val storageDir = requireContext().externalCacheDir\n        return File.createTempFile(\n            videoFileName,  /* prefix */\n            \".mp4\",  /* suffix */\n            storageDir /* directory */\n        )\n    }\n\n    private fun launchAudioIntent() {\n        val takeAudioIntent = Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION)\n        if (activity != null && takeAudioIntent.resolveActivity(requireActivity().packageManager) != null) {\n            // Create the File where the photo should go\n            var audioFile: File? = null\n            try {\n                audioFile = createAudioFile()\n                takeAudioIntent.putExtra(\"AudioPaths\", mAudioPath)\n            } catch (ex: IOException) {\n                //IO exception occurred\n            }\n            // Continue only if the File was successfully created\n            if (audioFile != null) {\n                mAudioPath = \"file:\" + audioFile.absolutePath\n                val audioURI: Uri = if (context != null) {\n                    FileProvider.getUriForFile(\n                        requireContext(), getString(R.string.chat360_file_provider), audioFile\n                    )\n                } else {\n                    Uri.fromFile(audioFile)\n                }\n                takeAudioIntent.putExtra(MediaStore.EXTRA_OUTPUT, audioURI)\n                disableShouldKeepApplicationInBackground()\n                startAudioActivity.launch(\n                    takeAudioIntent\n                )\n            }\n        }\n    }\n\n    private val startAudioActivity =\n        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n            if (it.resultCode == Activity.RESULT_OK) {\n                // do whatever with the data in the callback\n                val data = it.data\n                var results: Array<Uri?>? = null\n                // Check that the response is a good one\n                if (data != null && data.dataString != null) {\n                    val dataString = data.dataString\n                    results = arrayOf(Uri.parse(dataString))\n                } else if (data != null && data.clipData != null) {\n                    val count = data.clipData!!.itemCount\n                    if (count > 0) {\n                        results = arrayOfNulls(count)\n                        for (i in 0 until count) {\n                            results[i] = data.clipData!!.getItemAt(i).uri\n                        }\n                    }\n                } else {\n                    // If there is no data, then we may have taken a photo\n                    if (mAudioPath != null) {\n                        results = arrayOf(Uri.parse(mAudioPath))\n                        mAudioPath= null;\n                    }\n                }\n                mFilePathCallback!!.onReceiveValue(results)\n                mFilePathCallback = null\n            }\n        }\n\n    private fun checkForAudioPermission(context: Context): Boolean {\n        return if (ContextCompat.checkSelfPermission(\n                context, Manifest.permission.RECORD_AUDIO\n            ) == PackageManager.PERMISSION_GRANTED\n        ) {\n            true\n        } else {\n            requestedPermission = Manifest.permission.RECORD_AUDIO\n            requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)\n            false\n        }\n    }\n\n    //Will Start Camera\n    private fun launchCameraIntent() {\n        val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)\n        if (activity != null && takePictureIntent.resolveActivity(requireActivity().packageManager) != null) {\n            // Create the File where the photo should go\n            var photoFile: File? = null\n            try {\n                photoFile = createImageFile()\n                takePictureIntent.putExtra(\"PhotoPaths\", mCameraPhotoPath)\n            } catch (ex: IOException) {\n                //IO exception occurred\n            }\n            // Continue only if the File was successfully created\n            if (photoFile != null) {\n                mCameraPhotoPath = \"file:\" + photoFile.absolutePath\n                val photoURI: Uri = if (context != null) {\n                    FileProvider.getUriForFile(\n                        requireContext(), getString(R.string.chat360_file_provider), photoFile\n                    )\n                } else {\n                    Uri.fromFile(photoFile)\n                }\n                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI)\n                disableShouldKeepApplicationInBackground()\n                startCameraActivity.launch(\n                    takePictureIntent\n                )\n            } else {\n                Chat360SnackBarHelper().showMessageInSnackBar(\n                    requireView(), \"Not able to launch camera please use file option to pick image\"\n                )\n                isMediaUploadOptionSelected = false\n            }\n        }\n    }\n\n    private fun launchCameraVideoIntent() {\n        val takeVideoIntent = Intent(MediaStore.ACTION_VIDEO_CAPTURE)\n\n        if (activity != null && takeVideoIntent.resolveActivity(requireActivity().packageManager) != null) {\n            // Create the File where the video should go\n            var videoFile: File? = null\n            try {\n\n                videoFile = createVideoFile()\n            } catch (ex: IOException) {\n                // Handle IOException if necessary\n            }\n\n            // Continue only if the File was successfully created\n            if (videoFile != null) {\n                mCameraVideoPath = \"file:\" + videoFile.absolutePath\n                val videoURI: Uri = if (context != null) {\n                    FileProvider.getUriForFile(\n                        requireContext(), getString(R.string.chat360_file_provider), videoFile\n                    )\n                } else {\n                    Uri.fromFile(videoFile)\n                }\n                takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, videoURI)\n                takeVideoIntent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 0.7) // 0 = lowest quality\n                takeVideoIntent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, 10 * 1024 * 1024)\n                disableShouldKeepApplicationInBackground()\n                startVideoActivity.launch(takeVideoIntent)\n            } else {\n                Chat360SnackBarHelper().showMessageInSnackBar(\n                    requireView(), \"Not able to capture video. Please try again.\"\n                )\n            }\n        }\n    }\n\n\n    private val startVideoActivity =\n        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->\n            if (result.resultCode == Activity.RESULT_OK) {\n                // Handle the video capture result here\n                val data = result.data\n                var results: Array<Uri?>? = null\n                // Check that the response is a good one\n                if (data != null && data.dataString != null) {\n                    val dataString = data.dataString\n                    results = arrayOf(Uri.parse(dataString))\n                } else {\n                    // If there is no data, then we may have captured a video\n                    if (mCameraVideoPath != null) {\n                        results = arrayOf(Uri.parse(mCameraVideoPath))\n                        mCameraVideoPath = null;\n                    }\n                }\n                mFilePathCallback!!.onReceiveValue(results)\n                mFilePathCallback = null\n            } else if (result.resultCode == Activity.RESULT_CANCELED) {\n                isMediaUploadOptionSelected = false\n                mFilePathCallback!!.onReceiveValue(null)\n                mFilePathCallback = null\n            }\n        }\n\n\n    //result variable for the external intent of chat-bot\n    private val startCameraActivity =\n        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n            if (it.resultCode == Activity.RESULT_OK) {\n\n                // do whatever with the data in the callback\n                val data = it.data\n                var results: Array<Uri?>? = null\n                // Check that the response is a good one\n                if (data != null && data.dataString != null) {\n                    val dataString = data.dataString\n                    results = arrayOf(Uri.parse(dataString))\n                } else if (data != null && data.clipData != null) {\n                    val count = data.clipData!!.itemCount\n                    if (count > 0) {\n                        results = arrayOfNulls(count)\n                        for (i in 0 until count) {\n                            results[i] = data.clipData!!.getItemAt(i).uri\n                        }\n                    }\n                } else {\n                    // If there is no data, then we may have taken a photo\n                    if (mCameraPhotoPath != null) {\n                        results = arrayOf(Uri.parse(mCameraPhotoPath))\n                        mCameraPhotoPath = null;\n                    }\n                }\n\n                mFilePathCallback!!.onReceiveValue(results)\n                mFilePathCallback = null\n            } else if (it.resultCode == Activity.RESULT_CANCELED) {\n                isMediaUploadOptionSelected = false\n                mFilePathCallback!!.onReceiveValue(null)\n                mFilePathCallback = null\n            }\n        }\n\n    //Will verify if using camera is allowed by user\n    private fun checkForCameraPermission(context: Context): Boolean {\n        return if (ContextCompat.checkSelfPermission(\n                context, Manifest.permission.CAMERA\n            ) == PackageManager.PERMISSION_GRANTED\n        ) {\n            true\n        } else {\n            requestedPermission = Manifest.permission.CAMERA\n            requestPermissionLauncher.launch(Manifest.permission.CAMERA)\n            false\n        }\n    }\n\n    //If permission is given camera will be started\n    private fun checkAndLaunchCamera() {\n\n        if (context != null) {\n            if (hasCameraPermissionInManifest(requireContext())) {\n                if (checkForCameraPermission(requireContext())) {\n                    launchCameraIntent()\n                }\n            } else {\n                launchCameraIntent()\n            }\n        }\n    }\n\n    private fun checkAndLaunchVideoCamera() {\n\n        if (context != null) {\n            if (hasCameraPermissionInManifest(requireContext())) {\n                if (checkForCameraPermission(requireContext())) {\n                    launchCameraVideoIntent()\n                }\n            } else {\n                launchCameraVideoIntent()\n            }\n        }\n    }\n\n    //Checking if Permissions are added in AndroidManifest File\n    private fun hasCameraPermissionInManifest(context: Context): Boolean {\n        val packageInfo: PackageInfo?\n        try {\n            packageInfo = context.packageManager.getPackageInfo(\n                context.packageName, PackageManager.GET_PERMISSIONS\n            )\n            val permissions = packageInfo.requestedPermissions\n            if (permissions == null || permissions.isEmpty()) {\n                return false\n            }\n            for (perm in permissions) {\n                if (perm == Manifest.permission.CAMERA) return true\n            }\n        } catch (e: PackageManager.NameNotFoundException) {\n            //Exception occurred\n            return false\n        }\n        return false\n    }\n\n    //Upload multiple files\n    private fun isMultiFileUpload(): Boolean {\n        return isMultiFileUpload\n    }\n\n    //Keeping application in background is stopped\n    private fun disableShouldKeepApplicationInBackground() {\n        shouldKeepApplicationInBackground = false\n    }\n\n    //Launching file intent to upload any file\n    private fun launchFileIntent() {\n        val contentSelectionIntent = Intent(Intent.ACTION_GET_CONTENT)\n        contentSelectionIntent.addCategory(Intent.CATEGORY_OPENABLE)\n        contentSelectionIntent.type = \"*/*\"\n        if (isMultiFileUpload()) {\n            contentSelectionIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)\n        }\n        if (activity != null) {\n            disableShouldKeepApplicationInBackground()\n            startCameraActivity.launch(\n                contentSelectionIntent\n            )\n        }\n    }\n\n    private val requestPermissionLauncher = registerForActivityResult(\n        ActivityResultContracts.RequestPermission()\n    ) { isGranted: Boolean ->\n        if (requestedPermission == Manifest.permission.READ_EXTERNAL_STORAGE) {\n            if (isGranted) {\n                launchFileIntent()\n            } else {\n                resetFilePathCallback()\n                if (context != null) {\n                    Chat360SnackBarHelper().showSnackBarWithSettingAction(\n                        requireContext(),\n                        requireView(),\n                        \"Read storage permission required to complete this operation. Please enable it from app settings.\"\n                    )\n                }\n            }\n        } else if (requestedPermission == Manifest.permission.CAMERA) {\n            if (isGranted) {\n                launchCameraIntent()\n            } else {\n                resetFilePathCallback()\n                if (context != null) {\n                    Chat360SnackBarHelper().showSnackBarWithSettingAction(\n                        requireContext(),\n                        requireView(),\n                        \"Camera permission is required by the app to complete this operation. Please enable it from app settings.\"\n                    )\n                }\n            }\n\n        } else if (requestedPermission == Manifest.permission.ACCESS_FINE_LOCATION || requestedPermission == Manifest.permission.ACCESS_COARSE_LOCATION) {\n            if (isGranted && geoCallback != null && geoOrigin != null) {\n                geoCallback!!.invoke(geoOrigin, true, false)\n                geoCallback = null\n                geoOrigin = null\n            } else {\n                if (geoCallback != null && geoOrigin != null) {\n                    geoCallback!!.invoke(geoOrigin, false, false)\n                }\n                geoCallback = null\n                geoOrigin = null\n                if (context != null) {\n                    Chat360SnackBarHelper().showSnackBarWithSettingAction(\n                        requireContext(),\n                        requireView(),\n                        \"Location permission is required to complete this operation.\"\n                    )\n                }\n            }\n        }\n    }\n\n    private fun resetFilePathCallback() {\n        if (mFilePathCallback != null) {\n            mFilePathCallback!!.onReceiveValue(null)\n            mFilePathCallback = null\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chatbot/src/main/java/com/chat360/chatbot/android/ChatFragment.kt b/chatbot/src/main/java/com/chat360/chatbot/android/ChatFragment.kt
--- a/chatbot/src/main/java/com/chat360/chatbot/android/ChatFragment.kt	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/chatbot/src/main/java/com/chat360/chatbot/android/ChatFragment.kt	(date 1763636090859)
@@ -14,7 +14,6 @@
 import android.os.Build
 import android.os.Bundle
 import android.os.Handler
-import android.os.Looper
 import android.os.Message
 import android.provider.MediaStore
 import android.provider.Settings
@@ -37,6 +36,7 @@
 import com.chat360.chatbot.R
 import com.chat360.chatbot.common.Chat360SnackBarHelper
 import com.chat360.chatbot.common.Constants
+import com.chat360.chatbot.common.models.Chat360JSBridge
 import com.chat360.chatbot.common.models.ConfigService
 import com.google.android.material.bottomsheet.BottomSheetDialog
 import java.io.File
@@ -92,6 +92,7 @@
         setStatusBarColorFromHex()
         setCloseButtonColorFromHex()
         webView.clearCache(true)
+        Chat360JSBridge.registerWebView(webView)
     }
 
     override fun onDestroyView() {
@@ -245,10 +246,7 @@
                 val metadata = ConfigService.WebEventHandler.handleWindowEvent?.invoke(event)
 
                 metadata?.let {
-                    activity.sendResponseToWeb(
-                        "CHAT360_WINDOW_EVENT",
-                        it
-                    )
+                    Chat360JSBridge.send("CHAT360_WINDOW_EVENT_RESPONSE", it)
                 }
             } catch (e: Exception) {
                 Log.e("WebCommunicationBridge", "Error handling message", e)
Index: app/src/main/java/com/chat360/chat360demoapp/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chat360.chat360demoapp\n\n\nimport android.content.Intent\nimport android.os.Build\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport android.util.Log\nimport androidx.annotation.RequiresApi\nimport com.chat360.chatbot.common.Chat360\nimport com.chat360.chatbot.common.CoreConfigs\nimport com.google.android.material.button.MaterialButton\nimport com.google.android.material.floatingactionbutton.FloatingActionButton\n\n\nclass MainActivity : AppCompatActivity() {\n    private val botId = \"Your bot Id\"\n    private val flutter = false\n    private val meta = mapOf(\n        \"Key\" to \"Value\",\n    )\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        val chat360 = Chat360().getInstance()\n        chat360.coreConfig = CoreConfigs(botId, applicationContext, flutter, meta, false,false)\n\n        chat360.setBaseUrl(\"https://staging.chat360.io\");\n        chat360.setHandleWindowEvent { eventData ->\n            print(eventData)\n            val metaMap = mapOf(\n                \"dynamic_time\" to java.time.ZonedDateTime.now().toString()\n            )\n            metaMap\n        }\n\n\n        // To Change the color of status bar, by default it will pick app theme\n        chat360.coreConfig!!.statusBarColor = R.color.purple_500\n\n        // To Change the color of close button, default color is white\n        chat360.coreConfig!!.closeButtonColor = R.color.white\n\n        /* Note: if color is set from both setStatusBarColor and statusBarColorFromHex,\n         * statusBarColorFromHex will take priority\n         * */\n        // To set statusBarColor from hexadecimal color code\n        chat360.coreConfig!!.statusBarColorFromHex = \"#4299E1\"\n\n        /* Note: if color is set from both closeButtonColor and closeButtonColorHex,\n         * closeButtonColorHex will take priority\n         * */\n        // To set closeButtonColor from hexadecimal color code\n        chat360.coreConfig!!.closeButtonColorFromHex = \"#ffffff\"\n\n        findViewById<MaterialButton>(R.id.buttonOpenActivity).setOnClickListener {\n            chat360.startBot(this)\n        }\n        findViewById<FloatingActionButton>(R.id.floatingActionButton).setOnClickListener {\n            chat360.startBot(this)\n        }\n        findViewById<MaterialButton>(R.id.buttonOpenActivityFragment).setOnClickListener {\n            startActivity(Intent(this, ChatBotDemoActivity::class.java))\n        }\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/chat360/chat360demoapp/MainActivity.kt b/app/src/main/java/com/chat360/chat360demoapp/MainActivity.kt
--- a/app/src/main/java/com/chat360/chat360demoapp/MainActivity.kt	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/app/src/main/java/com/chat360/chat360demoapp/MainActivity.kt	(date 1757395318933)
@@ -14,7 +14,7 @@
 
 
 class MainActivity : AppCompatActivity() {
-    private val botId = "Your bot Id"
+    private val botId = "669d5510-4e85-49b3-b495-54da9e2cdbe6"
     private val flutter = false
     private val meta = mapOf(
         "Key" to "Value",
@@ -27,12 +27,25 @@
         val chat360 = Chat360().getInstance()
         chat360.coreConfig = CoreConfigs(botId, applicationContext, flutter, meta, false,false)
 
-        chat360.setBaseUrl("https://staging.chat360.io");
+        chat360.setBaseUrl("https://10.14.2.22");
         chat360.setHandleWindowEvent { eventData ->
             print(eventData)
-            val metaMap = mapOf(
-                "dynamic_time" to java.time.ZonedDateTime.now().toString()
-            )
+            var metaMap : Map<String, String> = mapOf()
+            if(eventData["type"] == "get_auth") {
+                 metaMap = mapOf(
+                    "token" to "New Token from app",
+                )
+            } else if(eventData["type"] == "get_date") {
+                metaMap = mapOf(
+                    "dynamic_date" to  java.time.ZonedDateTime.now().toString()
+                )
+            } else if (eventData["type"] == "get_user") {
+                metaMap = mapOf(
+                    "user_id" to "123456789",
+                    "user_name" to "John Doe"
+                )
+            }
+
             metaMap
         }
 
Index: .idea/runConfigurations.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/runConfigurations.xml b/.idea/runConfigurations.xml
new file mode 100644
--- /dev/null	(date 1756966602691)
+++ b/.idea/runConfigurations.xml	(date 1756966602691)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RunConfigurationProducerService">
+    <option name="ignoredProducers">
+      <set>
+        <option value="com.intellij.execution.junit.AbstractAllInDirectoryConfigurationProducer" />
+        <option value="com.intellij.execution.junit.AllInPackageConfigurationProducer" />
+        <option value="com.intellij.execution.junit.PatternConfigurationProducer" />
+        <option value="com.intellij.execution.junit.TestInClassConfigurationProducer" />
+        <option value="com.intellij.execution.junit.UniqueIdConfigurationProducer" />
+        <option value="com.intellij.execution.junit.testDiscovery.JUnitTestDiscoveryConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinJUnitRunConfigurationProducer" />
+        <option value="org.jetbrains.kotlin.idea.junit.KotlinPatternConfigurationProducer" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: app/src/main/java/com/chat360/chat360demoapp/ChatBotDemoActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chat360.chat360demoapp\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.fragment.app.Fragment\nimport com.chat360.chatbot.common.Chat360\nimport com.chat360.chatbot.common.CoreConfigs\n\nclass ChatBotDemoActivity : AppCompatActivity() {\n    private val botId = \"Your Bot Id\"\n    private val flutter = false\n    val meta = mapOf(\n        \"Key\" to \"Value\",\n    )\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_chat_bot_demo)\n        loadFragment(ChatBotDemoFragment())\n    }\n\n    private fun initialiseBot(): Chat360 {\n        //Get Chat360 instance\n        val chat360 = Chat360().getInstance()\n        chat360.coreConfig = CoreConfigs(botId, applicationContext,flutter,meta,false, false)\n\n        // To Change the color of status bar, by default it will pick app theme\n        chat360.coreConfig!!.statusBarColor = R.color.purple_500\n\n        // To Change the color of close button, default color is white\n        chat360.coreConfig!!.closeButtonColor = R.color.white\n\n        /* Note: if color is set from both setStatusBarColor and statusBarColorFromHex,\n         * statusBarColorFromHex will take priority\n         * */\n        // To set statusBarColor from hexadecimal color code\n        chat360.coreConfig!!.statusBarColorFromHex = \"#49c656\"\n\n        /* Note: if color is set from both closeButtonColor and closeButtonColorHex,\n         * closeButtonColorHex will take priority\n         * */\n        // To set closeButtonColor from hexadecimal color code\n        chat360.coreConfig!!.closeButtonColorFromHex = \"#ffffff\"\n        return chat360\n    }\n\n    private fun loadFragment(frag: Fragment) {\n\n        val transaction = supportFragmentManager.beginTransaction()\n        transaction.replace(R.id.fragmentContainerViewChatBot, frag)\n        transaction.addToBackStack(null)\n        transaction.commit()\n    }\n\n    fun showBotView() {\n        val chat360 = initialiseBot()\n        loadFragment(chat360.getChatBotView(this)!!)\n    }\n\n    override fun onBackPressed() {\n        super.onBackPressed()\n        try {\n            if (supportFragmentManager.backStackEntryCount == 1) {\n                finish()\n            } else {\n                onBackPressedDispatcher.onBackPressed()\n            }\n        } catch (e: Exception) {\n            //Some problem occurred please relaunch the bot\n            finish()\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/chat360/chat360demoapp/ChatBotDemoActivity.kt b/app/src/main/java/com/chat360/chat360demoapp/ChatBotDemoActivity.kt
--- a/app/src/main/java/com/chat360/chat360demoapp/ChatBotDemoActivity.kt	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/app/src/main/java/com/chat360/chat360demoapp/ChatBotDemoActivity.kt	(date 1756967017205)
@@ -7,7 +7,7 @@
 import com.chat360.chatbot.common.CoreConfigs
 
 class ChatBotDemoActivity : AppCompatActivity() {
-    private val botId = "Your Bot Id"
+    private val botId = "669d5510-4e85-49b3-b495-54da9e2cdbe6"
     private val flutter = false
     val meta = mapOf(
         "Key" to "Value",
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CompilerConfiguration\">\n    <bytecodeTargetLevel target=\"17\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
--- a/.idea/compiler.xml	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/.idea/compiler.xml	(date 1756749425018)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <bytecodeTargetLevel target="17" />
+    <bytecodeTargetLevel target="21" />
   </component>
 </project>
\ No newline at end of file
Index: chatbot/src/main/java/com/chat360/chatbot/common/models/Chat360JSBridge.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chatbot/src/main/java/com/chat360/chatbot/common/models/Chat360JSBridge.kt b/chatbot/src/main/java/com/chat360/chatbot/common/models/Chat360JSBridge.kt
new file mode 100644
--- /dev/null	(date 1763636208479)
+++ b/chatbot/src/main/java/com/chat360/chatbot/common/models/Chat360JSBridge.kt	(date 1763636208479)
@@ -0,0 +1,44 @@
+package com.chat360.chatbot.common.models
+
+import android.util.Log
+import android.webkit.WebView
+import java.lang.ref.WeakReference
+
+object Chat360JSBridge {
+
+    private var webViewRef: WeakReference<WebView>? = null
+
+    fun registerWebView(webView: WebView) {
+        webViewRef = WeakReference(webView)
+    }
+
+    fun send(type: String, data: Map<String, String>) {
+        val webView = webViewRef?.get()
+
+        if (webView == null) {
+            Log.e("Chat360JSBridge", "WebView reference lost, cannot send event")
+            return
+        }
+
+        var inner : String? = null
+        if (data.isEmpty()) {
+            inner = "{}"
+        }
+
+        inner = data?.entries?.joinToString(", ") { (key, value) ->
+            """$key: '$value'"""
+        }
+        Log.d("JavaScriptConsole", "{type: '$type', data:{ $inner} ")
+        val jsCode = "window.receiveFromApp({type: '$type', data: {$inner}});"
+
+        webView.post {
+            try {
+                webView.evaluateJavascript(jsCode) {
+                    Log.d("Chat360JSBridge", "Event sent: $type")
+                }
+            } catch (e: Exception) {
+                Log.e("Chat360JSBridge", "Error sending JS event", e)
+            }
+        }
+    }
+}
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"GradleMigrationSettings\" migrationVersion=\"1\" />\n  <component name=\"GradleSettings\">\n    <option name=\"linkedExternalProjectsSettings\">\n      <GradleProjectSettings>\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\n        <option name=\"gradleJvm\" value=\"#GRADLE_LOCAL_JAVA_HOME\" />\n        <option name=\"modules\">\n          <set>\n            <option value=\"$PROJECT_DIR$\" />\n            <option value=\"$PROJECT_DIR$/app\" />\n            <option value=\"$PROJECT_DIR$/chatbot\" />\n          </set>\n        </option>\n        <option name=\"resolveExternalAnnotations\" value=\"false\" />\n      </GradleProjectSettings>\n    </option>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/gradle.xml b/.idea/gradle.xml
--- a/.idea/gradle.xml	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/.idea/gradle.xml	(date 1756966602690)
@@ -4,6 +4,7 @@
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
+        <option name="testRunner" value="CHOOSE_PER_TEST" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
         <option name="gradleJvm" value="#GRADLE_LOCAL_JAVA_HOME" />
         <option name="modules">
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"DesignSurface\">\n    <option name=\"filePathToZoomLevelMap\">\n      <map>\n        <entry key=\"chatbot/src/main/res/drawable/ic_round_close_24.xml\" value=\"0.1945\" />\n        <entry key=\"chatbot/src/main/res/layout/activity_chat.xml\" value=\"0.15572916666666667\" />\n        <entry key=\"chatbot/src/main/res/layout/fragment_chat.xml\" value=\"0.22766926439502577\" />\n        <entry key=\"chatbot/src/main/res/layout/fragment_upload_bottom_sheet.xml\" value=\"0.335589599609375\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_17\" default=\"true\" project-jdk-name=\"jbr-17\" project-jdk-type=\"JavaSDK\">\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\n  </component>\n  <component name=\"ProjectType\">\n    <option name=\"id\" value=\"Android\" />\n  </component>\n  <component name=\"VisualizationToolProject\">\n    <option name=\"state\">\n      <ProjectState>\n        <option name=\"scale\" value=\"0.1\" />\n      </ProjectState>\n    </option>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/.idea/misc.xml	(date 1756749425014)
@@ -10,7 +10,7 @@
       </map>
     </option>
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="jbr-17" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="jbr-21" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
Index: .idea/deploymentTargetSelector.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"deploymentTargetSelector\">\n    <selectionStates>\n      <SelectionState runConfigName=\"app\">\n        <option name=\"selectionMode\" value=\"DROPDOWN\" />\n      </SelectionState>\n    </selectionStates>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/deploymentTargetSelector.xml b/.idea/deploymentTargetSelector.xml
--- a/.idea/deploymentTargetSelector.xml	(revision ca673a95401df0fa21140c4e6a151447d6220aaf)
+++ b/.idea/deploymentTargetSelector.xml	(date 1756749967177)
@@ -4,6 +4,14 @@
     <selectionStates>
       <SelectionState runConfigName="app">
         <option name="selectionMode" value="DROPDOWN" />
+        <DropdownSelection timestamp="2025-09-01T18:02:43.484004Z">
+          <Target type="DEFAULT_BOOT">
+            <handle>
+              <DeviceId pluginId="LocalEmulator" identifier="path=/Users/ks/.android/avd/Harshit_Android.avd" />
+            </handle>
+          </Target>
+        </DropdownSelection>
+        <DialogSelection />
       </SelectionState>
     </selectionStates>
   </component>
